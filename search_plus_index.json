{"./":{"url":"./","title":"介绍","keywords":"","body":"介绍 本课程通过对简书项目进行实战开发，从基础原理逐步深入讲解React中的主流技术以及实战中的应用。课程讲解全部使用React16最新语法，让同学们全方位理解应用React构建项目，直接上手中级以上难度React项目开发。 © 2020 Elton all right reserved，powered by Gitbook该文件最后修改时间： 2020-07-08 22:59:25 "},"part1/ch01-01.html":{"url":"part1/ch01-01.html","title":"React初探","keywords":"","body":"开发环境准备 使用Create React App来创建React应用 Create React App 是一个用于学习 React 的舒适环境，也是用 React 创建新的单页应用的最佳方式。 它会配置你的开发环境，以便使你能够使用最新的 JavaScript 特性，提供良好的开发体验，并为生产环境优化你的应用程序。你需要在你的机器上安装 Node >= 8.10 和 npm >= 5.6。要创建项目，请执行： npx create-react-app my-app cd my-app npm start 注意 第一行的 npx 不是拼写错误 —— 它是 npm 5.2+ 附带的 package 运行工具。 Create React App 不会处理后端逻辑或操纵数据库；它只是创建一个前端构建流水线（build pipeline），所以你可以使用它来配合任何你想使用的后端。它在内部使用 Babel 和 webpack，但你无需了解它们的任何细节。 当你准备好部署到生产环境时，执行 npm run build 会在 build 文件夹内生成你应用的优化版本。你能从它的 README 和用户指南了解 Create React App 的更多信息。 项目目录架构 src目录是项目的源文件，public目录是静态资源的目录。src/index.js是项目的入口文件。public/index.html是网站首页的模板页面。 © 2020 Elton all right reserved，powered by Gitbook该文件最后修改时间： 2020-07-08 23:43:03 "},"part1/ch01-03.html":{"url":"part1/ch01-03.html","title":"基础JSX语法","keywords":"","body":"React 基础JSX语法 JSX，是一个 JavaScript 的语法扩展。我们建议在 React 中配合使用 JSX，JSX 可以很好地描述 UI 应该呈现出它应有交互的本质形式。JSX 可能会使人联想到模版语言，但它具有 JavaScript 的全部功能。 const element = Hello, world!; JSX标签语法既不是字符串也不是 HTML。 在 JSX 中嵌入表达式 在下面的例子中，我们声明了一个名为 name 的变量，然后在 JSX 中使用它，并将它包裹在大括号中： const name = 'Josh Perez'; const element = ( Hello, {name} ); ReactDOM.render( element, document.getElementById('root') ); 在 JSX 语法中，你可以在大括号内放置任何有效的 JavaScript 表达式。例如，2 + 2，user.firstName 或 formatName(user) 都是有效的 JavaScript 表达式。 为了便于阅读，我们会将 JSX 拆分为多行。同时，我们建议将内容包裹在括号中，虽然这样做不是强制要求的，但是这可以避免遇到自动插入分号陷阱。 JSX 也是一个表达式 在编译之后，JSX 表达式会被转为普通 JavaScript 函数调用，并且对其取值后得到 JavaScript 对象。 也就是说，你可以在 if 语句和 for 循环的代码块中使用 JSX，将 JSX 赋值给变量，把 JSX 当作参数传入，以及从函数中返回 JSX： function getGreeting(user) { if (user) { return Hello, {formatName(user)}!; } return Hello, Stranger.; } JSX 特定属性 你可以通过使用引号，来将属性值指定为字符串字面量： const element = ; 也可以使用大括号，来在属性值中插入一个 JavaScript 表达式： const element = ; 在属性中嵌入 JavaScript 表达式时，不要在大括号外面加上引号。你应该仅使用引号（对于字符串值）或大括号（对于表达式）中的一个，对于同一属性不能同时使用这两种符号。 警告： 因为 JSX 语法上更接近 JavaScript 而不是 HTML，所以 React DOM 使用 camelCase（小驼峰命名）来定义属性的名称，而不使用 HTML 属性名称的命名约定。 例如，JSX 里的 class 变成了 className，而 tabindex 则变为 tabIndex。 使用 JSX 指定子元素 假如一个标签里面没有内容，你可以使用 /> 来闭合标签，就像 XML 语法一样： const element = ; SX 标签里能够包含很多子元素: const element = ( Hello! Good to see you here. ); JSX 防止注入攻击 你可以安全地在 JSX 当中插入用户输入内容： const title = response.potentiallyMaliciousInput; // 直接使用是安全的： const element = {title}; React DOM 在渲染所有输入内容之前，默认会进行转义。它可以确保在你的应用中，永远不会注入那些并非自己明确编写的内容。所有的内容在渲染之前都被转换成了字符串。这样可以有效地防止 XSS（cross-site-scripting, 跨站脚本）攻击。 JSX 表示对象 Babel 会把 JSX 转译成一个名为 React.createElement() 函数调用。 以下两种示例代码完全等效 const element = ( Hello, world! ); const element = React.createElement( 'h1', {className: 'greeting'}, 'Hello, world!' ); © 2020 Elton all right reserved，powered by Gitbook该文件最后修改时间： 2020-07-09 00:19:25 "},"part1/ch01-04.html":{"url":"part1/ch01-04.html","title":"元素渲染","keywords":"","body":"元素渲染 元素是构成 React 应用的最小砖块。元素描述了你在屏幕上想看到的内容。 const element = Hello, world; 与浏览器的 DOM 元素不同，React 元素是创建开销极小的普通对象。React DOM 会负责更新 DOM 来与 React 元素保持一致。组件是由元素构成的。 将一个元素渲染为 DOM 假设你的 HTML 文件某处有一个 ： 我们将其称为“根” DOM 节点，因为该节点内的所有内容都将由 React DOM 管理。仅使用 React 构建的应用通常只有单一的根 DOM 节点。 想要将一个 React 元素渲染到根 DOM 节点中，只需把它们一起传入 ReactDOM.render()： const element = Hello, world; ReactDOM.render(element, document.getElementById('root')); 更新已渲染的元素 React 元素是不可变对象。一旦被创建，你就无法更改它的子元素或者属性。一个元素就像电影的单帧：它代表了某个特定时刻的 UI。 根据我们已有的知识，更新 UI 唯一的方式是创建一个全新的元素，并将其传入 ReactDOM.render()。 考虑一个计时器的例子： function tick() { const element = ( Hello, world! It is {new Date().toLocaleTimeString()}. ); ReactDOM.render(element, document.getElementById('root')); } setInterval(tick, 1000); 这个例子会在 setInterval() 回调函数，每秒都调用 ReactDOM.render()。 注意： 在实践中，大多数 React 应用只会调用一次 ReactDOM.render()。在下一个章节，我们将学习如何将这些代码封装到有状态组件中。 React 只更新它需要更新的部分 React DOM 会将元素和它的子元素与它们之前的状态进行比较，并只会进行必要的更新来使 DOM 达到预期的状态。 你可以使用浏览器的检查元素工具查看上一个例子来确认这一点。 尽管每一秒我们都会新建一个描述整个 UI 树的元素，React DOM 只会更新实际改变了的内容，也就是例子中的文本节点。 根据我们的经验，考虑 UI 在任意给定时刻的状态，而不是随时间变化的过程，能够消灭一整类的 bug。 © 2020 Elton all right reserved，powered by Gitbook该文件最后修改时间： 2020-07-12 14:15:38 "},"part1/ch01-02.html":{"url":"part1/ch01-02.html","title":"组件基础","keywords":"","body":"组件 组件允许你将 UI 拆分为独立可复用的代码片段，并对每个片段进行独立构思。本指南旨在介绍组件的相关理念。你可以参考详细组件 API。 组件，从概念上类似于 JavaScript 函数。它接受任意的入参（即 “props”），并返回用于描述页面展示内容的 React 元素。 函数组件 定义组件最简单的方式就是编写 JavaScript 函数： function Welcome(props) { return Hello, {props.name}; } 该函数是一个有效的 React 组件，因为它接收唯一带有数据的 “props”（代表属性）对象与并返回一个 React 元素。这类组件被称为“函数组件”，因为它本质上就是 JavaScript 函数。 class 组件 你同时还可以使用 ES6 的 class 来定义组件： class Welcome extends React.Component { render() { return Hello, {this.props.name}; } } 上述两个组件在 React 里是等效的。 渲染组件 React的组件模板使用了JSX语法，如： const element = ; 不过，React 元素也可以是用户自定义的组件： const element = ; 当 React 元素为用户自定义组件时，它会将 JSX 所接收的属性（attributes）以及子组件（children）转换为单个对象传递给组件，这个对象被称之为 “props”。 例如，这段代码会在页面上渲染 “Hello, Sara”： function Welcome(props) { return Hello, {props.name}; } const element = ; ReactDOM.render( element, document.getElementById('root') ); 当使用了JSX语法后，页面头部必须引入React: import React from 'react'; 让我们来回顾一下这个例子中发生了什么： 我们调用 ReactDOM.render() 函数，并传入 作为参数。 React 调用 Welcome 组件，并将 {name: 'Sara'} 作为 props 传入。 Welcome 组件将 Hello, Sara 元素作为返回值。 React DOM 将 DOM 高效地更新为 Hello, Sara。 将此元素挂在到id为root的DOM元素上 注意： 组件名称必须以大写字母开头。 React 会将以小写字母开头的组件视为原生 DOM 标签。例如， 代表 HTML 的 div 标签，而 则代表一个组件，并且需在作用域内使用 Welcome。 组合组件 组件可以在其输出中引用其他组件。这就可以让我们用同一组件来抽象出任意层次的细节。按钮，表单，对话框，甚至整个屏幕的内容：在 React 应用程序中，这些通常都会以组件的形式表示。 例如，我们可以创建一个可以多次渲染 Welcome 组件的 App 组件： function Welcome(props) { return Hello, {props.name}; } function App() { return ( ); } ReactDOM.render( , document.getElementById('root') ); 通常来说，每个新的 React 应用程序的顶层组件都是 App 组件。 Props 的只读性 组件无论是使用函数声明还是通过 class 声明，都决不能修改自身的 props。来看下这个 sum 函数： function sum(a, b) { return a + b; } 这样的函数被称为“纯函数”，因为该函数不会尝试更改入参，且多次调用下相同的入参始终返回相同的结果。 相反，下面这个函数则不是纯函数，因为它更改了自己的入参： function withdraw(account, amount) { account.total -= amount; } React 非常灵活，但它也有一个严格的规则： 所有 React 组件都必须像纯函数一样保护它们的 props 不被更改。 当然，应用程序的 UI 是动态的，并会伴随着时间的推移而变化。在下一章节中，我们将介绍一种新的概念，称之为 “state”。在不违反上述规则的情况下，state 允许 React 组件随用户操作、网络响应或者其他变化而动态更改输出内容。 © 2020 Elton all right reserved，powered by Gitbook该文件最后修改时间： 2020-07-12 14:16:07 "},"part1/ch01-05.html":{"url":"part1/ch01-05.html","title":"State & 生命周期","keywords":"","body":"State & 生命周期 一个完整的component和生命周期的例子： class Clock extends React.Component { //通过ES6的类语法，集成React.Component来生成组件 constructor(props) { super(props); // 向父组件传递props的参数 this.state = {date: new Date()}; //初始化state，只有在构造函数里才能这样给state赋值，其他情况都要用setState函数。 } componentDidMount() { //挂载组件的时候执行 this.timerID = setInterval( () => this.tick(), //箭头匿名函数，执行tick()里的setState方法 1000 ); } componentWillUnmount() { // 卸载组件的时候执行，释放资源 clearInterval(this.timerID); } tick() { this.setState({ date: new Date() }); } render() { //组件挂载或者内容变更是（这里是state），执行render方法 return ( Hello, world! It is {this.state.date.toLocaleTimeString()}. ); } } ReactDOM.render( , document.getElementById('root') ); 让我们来快速概括一下发生了什么和这些方法的调用顺序： 当 被传给 ReactDOM.render()的时候，React 会调用 Clock 组件的构造函数。因为 Clock 需要显示当前的时间，所以它会用一个包含当前时间的对象来初始化 this.state。我们会在之后更新 state。 之后 React 会调用组件的 render() 方法。这就是 React 确定该在页面上展示什么的方式。然后 React 更新 DOM 来匹配 Clock 渲染的输出。 当 Clock 的输出被插入到 DOM 中后，React 就会调用 ComponentDidMount() 生命周期方法。在这个方法中，Clock 组件向浏览器请求设置一个计时器来每秒调用一次组件的 tick() 方法。 浏览器每秒都会调用一次 tick() 方法。 在这方法之中，Clock 组件会通过调用 setState() 来计划进行一次 UI 更新。得益于 setState() 的调用，React 能够知道 state 已经改变了，然后会重新调用 render() 方法来确定页面上该显示什么。这一次，render() 方法中的 this.state.date 就不一样了，如此以来就会渲染输出更新过的时间。React 也会相应的更新 DOM。 一旦 Clock 组件从 DOM 中被移除，React 就会调用 componentWillUnmount() 生命周期方法，这样计时器就停止了。 正确地使用 State 关于 setState() 你应该了解三件事： 不要直接修改 State 例如，此代码不会重新渲染组件： // Wrong this.state.comment = 'Hello'; 而是应该使用 setState(): // Correct this.setState({comment: 'Hello'}); 构造函数是唯一可以给 this.state 赋值的地方： State 的更新可能是异步的 出于性能考虑，React 可能会把多个 setState() 调用合并成一个调用。 因为 this.props 和 this.state 可能会异步更新，所以你不要依赖他们的值来更新下一个状态。 例如，此代码可能会无法更新计数器： // Wrong this.setState({ counter: this.state.counter + this.props.increment, }); 要解决这个问题，可以让 setState() 接收一个函数而不是一个对象。这个函数用上一个 state 作为第一个参数，将此次更新被应用时的 props 做为第二个参数： // Correct this.setState((state, props) => ({ counter: state.counter + props.increment })); 上面使用了箭头函数，不过使用普通的函数也同样可以： // Correct this.setState(function(state, props) { return { counter: state.counter + props.increment }; }); State 的更新会被合并 当你调用 setState() 的时候，React 会把你提供的对象合并到当前的 state。 例如，你的 state 包含几个独立的变量： constructor(props) { super(props); this.state = { posts: [], comments: [] }; } 然后你可以分别调用 setState() 来单独地更新它们： componentDidMount() { fetchPosts().then(response => { this.setState({ posts: response.posts }); }); fetchComments().then(response => { this.setState({ comments: response.comments }); }); } 这里的合并是浅合并，所以 this.setState({comments}) 完整保留了 this.state.posts， 但是完全替换了 this.state.comments。 © 2020 Elton all right reserved，powered by Gitbook该文件最后修改时间： 2020-07-17 23:32:34 "},"part1/ch01-06.html":{"url":"part1/ch01-06.html","title":"事件处理","keywords":"","body":"事件处理 React 元素的事件处理和 DOM 元素的很相似，但是有一点语法上的不同： React 事件的命名采用小驼峰式（camelCase），而不是纯小写。 使用 JSX 语法时你需要传入一个函数作为事件处理函数，而不是一个字符串。 例如，传统的 HTML： Activate Lasers 在 React 中略微不同： Activate Lasers 使用 React 时，你一般不需要使用 addEventListener 为已创建的 DOM 元素添加监听器。事实上，你只需要在该元素初始渲染的时候添加监听器即可。 当你使用 ES6 class 语法定义一个组件的时候，通常的做法是将事件处理函数声明为 class 中的方法。例如，下面的 Toggle 组件会渲染一个让用户切换开关状态的按钮： class Toggle extends React.Component { constructor(props) { super(props); this.state = {isToggleOn: true}; // 为了在回调中使用 `this`，这个绑定是必不可少的 this.handleClick = this.handleClick.bind(this); } handleClick() { this.setState(state => ({ isToggleOn: !state.isToggleOn })); } render() { return ( {this.state.isToggleOn ? 'ON' : 'OFF'} ); } } ReactDOM.render( , document.getElementById('root') ); 你必须谨慎对待 JSX 回调函数中的 this，在 JavaScript 中，class 的方法默认不会绑定 this。如果你忘记绑定 this.handleClick 并把它传入了 onClick，当你调用这个函数的时候 this 的值为 undefined。 这并不是 React 特有的行为；这其实与 JavaScript 函数工作原理有关。通常情况下，如果你没有在方法后面添加 ()，例如 onClick={this.handleClick}，你应该为这个方法绑定 this。 如果觉得使用 bind 很麻烦，这里有两种方式可以解决。如果你正在使用实验性的 public class fields 语法，你可以使用 class fields 正确的绑定回调函数： class LoggingButton extends React.Component { // 此语法确保 `handleClick` 内的 `this` 已被绑定。 // 注意: 这是 *实验性* 语法。 handleClick = () => { console.log('this is:', this); } render() { return ( Click me ); } } Create React App 默认启用此语法。 如果你没有使用 class fields 语法，你可以在回调中使用箭头函数： class LoggingButton extends React.Component { handleClick() { console.log('this is:', this); } render() { // 此语法确保 `handleClick` 内的 `this` 已被绑定。 return ( this.handleClick()}> Click me ); } } 此语法问题在于每次渲染 LoggingButton 时都会创建不同的回调函数。在大多数情况下，这没什么问题，但如果该回调函数作为 prop 传入子组件时，这些组件可能会进行额外的重新渲染。我们通常建议在构造器中绑定或使用 class fields 语法来避免这类性能问题。 向事件处理程序传递参数 在循环中，通常我们会为事件处理函数传递额外的参数。例如，若 id 是你要删除那一行的 ID，以下两种方式都可以向事件处理函数传递参数： this.deleteRow(id, e)}>Delete Row Delete Row 上述两种方式是等价的，分别通过箭头函数和 Function.prototype.bind 来实现。 在这两种情况下，React 的事件对象 e 会被作为第二个参数传递。如果通过箭头函数的方式，事件对象必须显式的进行传递，而通过 bind 的方式，事件对象以及更多的参数将会被隐式的进行传递。 © 2020 Elton all right reserved，powered by Gitbook该文件最后修改时间： 2020-07-18 00:29:25 "},"part1/ch02-01.html":{"url":"part1/ch02-01.html","title":"React基础讲解","keywords":"","body":"© 2020 Elton all right reserved，powered by Gitbook该文件最后修改时间： 2020-07-10 23:59:25 "}}